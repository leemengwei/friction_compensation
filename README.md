
# Friction_compensation
#APIS---------------------------------------------------
#SRC下：

#数学模型训练主程序：
#输出模型文件说明：
#在声明训练数据的分割方式后，（mode=匀速加速or低速高速），将使用线性、非线性两种方式，训练各两个模型。（两种分割数据的方式都做完，将会共有四个模型。）此时，由于拟合求解，所以这里对于每种分割方式，两个模型一起串行训练，执行一次脚本即可生成该mode下所有关于传统数学模型的models。
#如下得到四个：
#python classical_train.py  --mode=acc_uniform -V -Q
#python classical_train.py  --mode=low_high -V -Q


#神经网络训练主程序：
#输出模型文件说明：
#同样，声明训练数据的分割方式后，（mode=匀速加速or低速高速），仍然将需要NN针对不同mode训练两个阶段的不同的模型。但此时由于迭代训练速度很慢，所以这里不再像拟合传统数学模型那样串行训练，而是进一步根据further_mode，执行一次，得到具体的关于该分割mode下哪阶段的model。
#如下分别得到四个：
#python NN_train.py  --mode=acc_uniform -Q --further_mode=acc
#python NN_train.py  --mode=acc_uniform -Q --further_mode=uniform
#python NN_train.py  --mode=low_high -Q --further_mode=low
#python NN_train.py  --mode=low_high -Q --further_mode=high

#部署：
#部署线性模型： python classical_deploy.py --mode='low_high'（ --data_path="../data/plan.csv" --max_force=1 -V --axis_num=4）
#部署NN模型： python NN_deploy.py  --mode='acc_uniform'（ --data_path="../data/plan.csv" --max_force=1 --V --axis_num=4）

#Production产品化，同时上述deploy将使用torch.jit生成C版本的weights
#产品化C调用方法见另一Readme，在C_production中。需要cudnn和cuda支持。

#最终生成的补偿文件：
#线性模型： output下classical_compensation.txt
#NN模型： output下NN_compensation.txt











#Logs-----------------------------------------------
10-30日志：
加上了多轴的输入，这个一定要，即使像1轴这些，也必须要，因为以后考虑复杂的组合动作过程中，很可能一轴也在以一个规律加减速运动，对后端关节产生作用。
未加decay， Adam方法学习率乱变不好训，使用SGD；BN不好训练，不要BN了, SGD=0.01, batch=1000这样可以。
写deploy时注意到需要读取六个轴的pos规划、speed规划、总/分torque规划。


11-1日志：
已经区分了M+C和G的输入，但实质上是M+C和M+C+G，*尚未做两者的白化*，但应该是小问题。
前面有一小段采集bug数据删除了，中间还有一段异常，*尚未解决*。
重要！！（*还没画，必须画出来！*）：所有维度的数据扩增没有做，需要做个别axis的fillup（index:0,），所以目前实际中不能用神经网络的输出、或者，只能采一条，训一条，用一条（即适用重复动作）！








#Reports---------------------------------------------------
目前情况：
目前基本完成了算法的整体架构，包括数学线性、非线性模型补偿的、和神经网络补偿的（强化学习相关架构还没有），总得来的说截止目前进行还算顺利。考虑到先推流程，目前我只给到王工数学的补偿模型。
具体如下：
1、全体数据集按照不同路径分出了20%测试集合；
2、在计算相对误差的时候剔除了原始数据中太小造成失真的部分，相对误差计算方法：（规划+补偿-实际反馈）/实际反馈；
3、针对4轴单轴使用数学模型进行摩擦力补偿，传统建模公式中摩擦力仅仅和改轴有关，其他轴没有作为输入。线性模型得到的封闭解误差相对误差13.31%，基本是极限了；
4、针对4轴单轴使用神经网络模型进行摩擦力补偿，这时必要的轴数据都已添加，但由于6个维度上采样空间很大（虽然我们采了一些），为保险起见还是只推荐去补偿走过的路径看效果；
5、神经网络补偿可以把误差降到约6%左右，且还有下降空间，没有过拟合；
其他：
1、以上讨论仅限于匀速运动阶段；
2、在本问题上我验证了梯度下降求解方法，对于传统数学模型来说，最终的解和拟合求得的封闭解没有区别，所以后续我弱化了梯度下降方法;
3、至于非线性模型我也完成了建模和求解，效果和线性模型几乎一样，我看了非线性的各项，推测造成这种现象可能的原因是因为非线性补偿模型是针对于在物体开始运动的临界状态，以及在速度较大的部分影响摩擦力了，而我们的数据最大速度也不大，使得两者表现差不多，当我去除加速、临界的采样点时，两者更加一致，说明非线性想没怎么发挥作用，所以后续的研究中我弱化了非线性模型；



#Importants---------------------------------------------
*严格的话需要使用真实位置反馈重新规划一次，得到新的规划全力矩。所以实际上我们训练时，补充的量中包含了规划路径和实际路径不一样的影响。
*网络可以无法接受的情况是具有相同输入，却对应不同标签的情况，所以G、M+C一定要分开作为两维度。类似的其它问题还包括：输入维度不足导致的模型自由度不够的情况——需要对自由度做相应探索。
*可探索的自由度（有实际意义的）需要提前得知。







#Notes----------------------------------------------------
实验：第4轴在动。

又确认了下：
axc_torque_ffw_gravity_4  ==  最终电机输出的  == pid+前馈

×××规划：
第二列ms是时间，        Note: 来回往复，貌似没有间断, 需要自己取出。
第3列到第8各轴位置参考值，  Note: 所谓参考是指通过动力学模型的简单的规划。
第9到14列是速度参考值，             Note：规划为了保证其他轴静止，也需要给力、给速度。
第15到20列是计算力矩（除掉重力项）， Note: M(a)+C(v)，4轴朝天，有没有重力项一样。
#axc_torque_ffw_3
第39到44是计算力矩（全力矩）    Note:M(a)+C(v)+G(q),匀速阶段全力矩也差不多，只有在短暂的加速时力矩不一样。注意， 此处理论力矩纯路径规划给出的，而真实的路径并不是规划的，所以严格的话需要使用真实位置反馈重新规划一次，得到新的规划全力矩。
#axc_torque_ffw_gravity_3

×××过后：
第33到38是反馈力矩，   Note：即路“径规划+PID”的力，是“事后”的力。最终目标就是想预先知道这个力。重力项。
#servo_feedback_torque_3
第21到26是反馈位置，    Note: 不太用管，也是“事后”的。但可能训练要用。
第27到32是反馈速度，    Note: 不太用管，也是“事后”的。但可能训练要用。

使用时：
    提前得知：
        1、可知每个轴的位置随时间的规划；
        2、可知每个轴的速度随时间的规划；
        3、可知每个轴的力矩（G与M+C）随时间的规划；
    事后得知：
        4、得知每个轴的实际的位置随时间的变化；
        5、得知每个轴的实际的速度随时间的变化；
        6、得知每个轴的实际的力矩“前馈+反馈控制”；


作用的方式：

理想目标：    1）规划的力矩 + 摩擦力于运动路径 + 规划的不足 + 摩擦补偿    ==> 规划的运动（如果全部补偿，则此时PID=0）
                                                            
实测数据：    2）规划的力矩 + 摩擦力于运动路径 + 实时PID补偿             ==> 实际的运动（尽可能贴近规划的运动）
                      |                             |    |
                      --------- (实测输出的力)-------    --->（规划的不足+摩擦补偿）

实际目标：    3）规划的力矩 + 摩擦力于运动路径 + 预期的总补偿 + 实时PID补偿' ==> 补偿的运动



